const cds = require('@sap/cds');

module.exports = cds.service.impl(async function () {
    const { PostingPeriodRequests, TimeLogs } = this.entities;

    this.on('openPeriod', async (req) => {
        const { period, year, companyCode, variant, reason } = req.data;

        // 1. Create a new request record
        const newRequest = {
            period,
            year,
            companyCode,
            variant,
            reason,
            status: 'PENDING',
            ticketId: `TICKET-${Math.floor(Math.random() * 10000)}`, // Mock ticket creation
            payload: JSON.stringify({
                period,
                year,
                companyCode,
                variant,
                reason,
                action: 'OPEN',
                timestamp: new Date().toISOString()
            })
        };

        const result = await INSERT.into(PostingPeriodRequests).entries(newRequest);
        // When using HANA, INSERT returns the number of affected rows or the inserted object depending on configuration.
        // However, for UUIDs generated by CAP, we can often rely on the input data if we generated it, 
        // OR we need to fetch it back if DB generated it. 
        // Let's try to fetch the latest record for this ticketId to be safe, or check if result itself has the ID.

        // A more robust way for CAP + HANA:
        const request = await SELECT.one.from(PostingPeriodRequests).where({ ticketId: newRequest.ticketId });
        const requestId = request.ID;

        // 2. Mock HTTP call to SAP BTP Integration Suite
        // In a real scenario, we would use cds.connect.to('Destination').post(...)
        // 2. Mock HTTP call to SAP BTP Integration Suite - REMOVED, moved to sendToSap
        // 3. Update status to OPEN - REMOVED, moved to sendToSap

        // 4. Start Time Tracking (Optional: maybe start it here or after approval? Let's keep it here for now as "request time")
        await INSERT.into(TimeLogs).entries({
            requestId: requestId,
            startTime: new Date().toISOString(),
            activity: 'Manual Posting Activity'
        });

        return `Period ${period}/${year} request created. Status: PENDING.`;
    });

    this.on('closePeriod', async (req) => {
        const { period, year, companyCode, variant, reason } = req.data;

        // 1. Create a new request record for closing
        const newRequest = {
            period,
            year,
            companyCode,
            variant,
            reason,
            status: 'PENDING',
            ticketId: `TICKET-${Math.floor(Math.random() * 10000)}`,
            payload: JSON.stringify({
                period,
                year,
                companyCode,
                variant,
                reason,
                action: 'CLOSE',
                timestamp: new Date().toISOString()
            })
        };

        const result = await INSERT.into(PostingPeriodRequests).entries(newRequest);
        const request = await SELECT.one.from(PostingPeriodRequests).where({ ticketId: newRequest.ticketId });
        const requestId = request.ID;

        // 2. Mock HTTP call to SAP BTP Integration Suite - REMOVED, moved to sendToSap
        // 3. Update status to CLOSED - REMOVED, moved to sendToSap

        // 4. Log time
        await INSERT.into(TimeLogs).entries({
            requestId: requestId,
            startTime: new Date().toISOString(),
            endTime: new Date().toISOString(),
            duration: 0,
            activity: 'Manual Close Activity'
        });

        return `Period ${period}/${year} close request created. Status: PENDING.`;
    });

    this.on('closeRequest', async (req) => {
        const { requestId } = req.data;

        const request = await SELECT.one.from(PostingPeriodRequests).where({ ID: requestId });
        if (!request) return req.error(404, 'Request not found');

        if (request.status !== 'OPEN') return req.error(400, 'Period is not open');

        // 1. Mock HTTP call to SAP BTP Integration Suite
        console.log(`[Mock Integration] Calling SAP BTP to close period ${request.period}/${request.year}...`);
        await new Promise(resolve => setTimeout(resolve, 1000));
        console.log(`[Mock Integration] SAP BTP responded: Success`);

        // 2. Update status to CLOSED
        await UPDATE(PostingPeriodRequests).set({ status: 'CLOSED' }).where({ ID: requestId });

        // 3. Stop Time Tracking
        const timeLog = await SELECT.one.from(TimeLogs).where({ requestId: requestId, endTime: null });
        if (timeLog) {
            const endTime = new Date();
            const startTime = new Date(timeLog.startTime);
            const duration = Math.round((endTime - startTime) / 60000); // minutes

            await UPDATE(TimeLogs).set({
                endTime: endTime.toISOString(),
                duration: duration
            }).where({ ID: timeLog.ID });
        }

        return `Period ${request.period}/${request.year} closed successfully.`;
    });

    this.on('sendToSap', async (req) => {
        const { requestId } = req.data;

        const request = await SELECT.one.from(PostingPeriodRequests).where({ ID: requestId });
        if (!request) return req.error(404, 'Request not found');

        // Parse payload to simulate sending it
        const payload = JSON.parse(request.payload || '{}');
        console.log(`[Mock Integration] Sending payload to SAP BTP Integration Suite:`, payload);

        // Simulate external API call
        await new Promise(resolve => setTimeout(resolve, 2000));

        // Simulate success response
        console.log(`[Mock Integration] SAP BTP responded: Success. Function Module executed.`);

        // Update status to 'SENT_TO_SAP' or similar, or just keep it as is but maybe add a comment
        // For this requirement, let's assume 'SENT_TO_SAP' is a new status or we just log it. 
        // The user asked to "update the status". Let's assume a new status 'PROCESSED' or similar if not defined.
        // Checking the enum: OPEN, CLOSED, PENDING. Let's stick to the flow. 
        // If it was PENDING, it becomes OPEN/CLOSED. 
        // Wait, the previous logic immediately set it to OPEN/CLOSED. 
        // The requirement says "On action the json data should be used to call... and return the status. This status must be updated".
        // Let's assume the "Send to SAP" is the *actual* step that should finalize the status, 
        // OR it's a re-trigger. 
        // Let's assume the previous immediate update was a mock, and now we want this explicit button.
        // But to avoid breaking existing flow, let's say this button is for auditing or re-sending.
        // OR, maybe the user wants the initial status to be PENDING, and ONLY after "Send to SAP" it becomes OPEN/CLOSED.
        // Let's adjust: Initial create -> PENDING. "Send to SAP" -> OPEN/CLOSED.

        // RE-READING: "Submit button... should accept submission without validation... create HANA table entry... display records".
        // "In the recent requests add a link View data... create a button 'Send to SAP'. On action... update the status".
        // This implies the initial submission should NOT set it to OPEN/CLOSED immediately, but leave it as PENDING.
        // So I should REMOVE the immediate status update from openPeriod/closePeriod.

        let newStatus = payload.action === 'OPEN' ? 'OPEN' : 'CLOSED';

        await UPDATE(PostingPeriodRequests).set({ status: newStatus }).where({ ID: requestId });

        return `Request ${request.ticketId} sent to SAP. Status updated to ${newStatus}.`;
    });
});
